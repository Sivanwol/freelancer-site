---
description: Analyzes and safely cleans up local Git branches. Categorizes branches by merge status, staleness, and remote tracking.
globs: **/.git/**
---

# Git Branch Cleanup Rule

# Instructions

You are a Git Safety Expert. When the user asks to clean up, prune, or organize branches, you must strictly follow the **Analyze -> Categorize -> Confirm -> Execute** workflow.

## Phase 1: Analysis (Run First)

**Do not** suggest deletion commands immediately. First, run these diagnostic commands to gather state:

```bash
# 1. Detect Base Branch (Prioritize 'develop' if auto-detect fails)
BASE_BRANCH="$(git symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null | sed 's@^origin/@@')"
if [ -z "$BASE_BRANCH" ]; then
  # If origin/HEAD is missing, check if 'develop' exists locally, otherwise fallback to main
  git show-ref --verify --quiet refs/heads/develop && BASE_BRANCH=develop || BASE_BRANCH=main
fi
echo "Base branch detected as: $BASE_BRANCH"

# 2. List all branches with last commit date, tracking status, and subject
git for-each-ref --sort=-committerdate refs/heads/ \
  --format='%(refname:short)|%(committerdate:relative)|%(upstream:trackshort)|%(contents:subject)'

# 3. List branches merged into base
git branch --merged "$BASE_BRANCH"

# 4. Check for "gone" remotes (remote branch deleted)
git branch -vv | grep -F ': gone]' || true

# 5. List active worktrees
git worktree list

# 6. Check for unpushed commits (ahead of upstream)
git for-each-ref refs/heads --format='%(refname:short) %(upstream:trackshort)' | grep '>' || true
```
## Phase 2: Confirmation
Show the list from Phase 1 to the user. Safety Warning: Check if any important branches (like develop, main, master) appear in this list. If develop appears, warn the user NOT to delete it.

Ask: "Ready to delete these [gone] branches?"

## Phase 3: Execution Script
Once confirmed, use this exact interactive script. It allows the user to choose "Delete All" or select specific branches by name (comma-separated).

```bash 
# 1. Gather [gone] branches
GONE_BRANCHES=$(git branch -vv | grep ': gone]' | sed 's/^[+* ]//' | awk '{print $1}')

if [ -z "$GONE_BRANCHES" ]; then
  echo "No 'gone' branches found."
  exit 0
fi

echo "The following branches have deleted remotes:"
echo "$GONE_BRANCHES"
echo "---------------------------------------------"

# 2. Interactive Selection
read -r -p "Delete ALL these branches? [Y/n] " confirm_all

if [[ "$confirm_all" =~ ^[Nn] ]]; then
  echo "Enter branches to delete (comma-separated, e.g. branch1,branch2)."
  read -r -p "Selection (Press Enter to delete ALL): " selection
  
  if [ -n "$selection" ]; then
    # Convert commas to spaces for the loop
    TARGET_LIST=$(echo "$selection" | tr ',' ' ')
  else
    # Fallback: No input means delete all
    TARGET_LIST="$GONE_BRANCHES"
  fi
else
  # Default: Delete all
  TARGET_LIST="$GONE_BRANCHES"
fi

# 3. Execution Loop
for branch in $TARGET_LIST; do
  # Trim whitespace
  branch=$(echo "$branch" | xargs)
  [ -z "$branch" ] && continue

  # Safety Guard: Skip protected branches
  if [[ "$branch" == "develop" || "$branch" == "main" || "$branch" == "master" ]]; then
    echo "⚠️  Skipping protected branch: $branch"
    continue
  fi

  echo "Processing branch: $branch"

  # Check for associated worktree
  worktree_path=$(git worktree list | grep "\[$branch\]" | awk '{print $1}')
  
  # If worktree exists, remove it first
  if [ ! -z "$worktree_path" ]; then
    echo "  Found worktree at: $worktree_path"
    repo_toplevel=$(git rev-parse --show-toplevel)
    if [ "$worktree_path" != "$repo_toplevel" ]; then
      echo "  Removing worktree..."
      git worktree remove --force "$worktree_path"
    fi
  fi

  # Force delete the branch
  git branch -D "$branch"
done
```